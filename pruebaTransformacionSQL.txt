1.- Crear tabla entidad con todos los tipos de atributos -> done
2.- Interrelaciones N:M normales -> done
3.- Interrelaciones 1:N normales -> done
4.- Interrelaciones 1:1 normales -> mirar un momento cuando una es (0,1) y otra es (1,1)
5.- Interrelaciones recursivas de todos los tipos normales -> 
6.- Interrelaciones N:M con atributos propios ->
7.- Interrelaciones 1:N con atributos propios ->
8.- Interrelaciones 1:1 con atributos propios ->




Escenario,¿Crea Tabla?,Atributo Clave de Relación,Clave Propagada (FK)
"0,1 - 0,1 (Puro)",Sí,UNIQUE NOT NULL,UNIQUE NOT NULL
"1,1 - 0,1 (Propagado)",No,Se une a la PRIMARY KEY,UNIQUE NOT NULL
"1,1 - 1,1 (Propagado)",No,Se une a la PRIMARY KEY,UNIQUE NOT NULL


Escenario,Transformación,Restricción de la FK (Clave Propagada),Razón Técnica
"1. (0,1) - (0,1)",Nueva Tabla,UNIQUE NOT NULL,"Al ser una tabla de relación, un ID es PK y el otro debe ser UNIQUE para que no se repitan parejas. Son NOT NULL porque la fila no existe sin ellos."
"2. (1,1) - (0,1)","Propagación (de 1,1 a 0,1)",UNIQUE NOT NULL,"Es UNIQUE para que la relación no se vuelva 1:N. Es NOT NULL (según PDF 2 pág. 6) para asegurar que la entidad obligatoria (1,1) siempre tenga su pareja."
"3. (1,1) - (1,1)",Propagación (Cualquiera),UNIQUE NOT NULL,"Es la restricción más fuerte. Ambas entidades son obligatorias y exclusivas, por lo que la clave ajena no puede repetirse ni ser nula."







/*const allRelations = this.findConnectedRelations(entity, root);
        const uniqueRelations = Array.from(new Map(allRelations.map(r => [r.id, r])).values());
        uniqueRelations.forEach(relation => {
            if (this.getCardinality(relation) === '1:1') {
                const myEdges = root.children.filter(child => {
                    const isEdge = child.type && child.type.includes('edge');
                    if (!isEdge) return false;
                    const e = child as GEdge;
                    return (e.sourceId === entity.id && e.targetId === relation.id) || 
                        (e.sourceId === relation.id && e.targetId === entity.id);
                }) as GEdge[];
                myEdges.forEach(myEdge => {
                    if (myEdge && this.getCardinality(myEdge).includes('0')) {
                        const connected = this.findConnectedEntities(relation, root);
                        let other = connected.find(e => e.id !== entity.id);
                        if (!other) {
                            const isReflexive = connected.length > 0 && connected.every(e => e.id === entity.id);
                            if (isReflexive) other = entity;
                        }
                        if (other) {
                            let otherEdge: GEdge | undefined;
                            if (entity.id === other.id) {
                                otherEdge = root.children.find(child => {
                                    const isEdge = child.type && child.type.includes('edge'); 
                                    if (!isEdge) return false;
                                    const e = child as GEdge;
                                    const connects = (e.sourceId === entity.id && e.targetId === relation.id) || (e.sourceId === relation.id && e.targetId === entity.id);
                                    return connects && e.id !== myEdge.id;
                                }) as GEdge | undefined;
                            } else otherEdge = this.findEdgeBetween(other, relation, root);

                            if (otherEdge && this.getCardinality(otherEdge).includes('1')) {
                                const otherPK = this.findPrimaryKey(other, root);
                                if (otherPK) {
                                    const { name, type } = this.splitLabelAttribute(this.getSafeName(otherPK));
                                    const isReflexive = entity.id === other.id;
                                    const relName = this.getSafeName(relation);
                                    const prefix = relName.substring(0, 3);
                                    const colName = isReflexive ? `${prefix}_${name}` : name;
                                    const otherTableName = this.getSafeName(other);
                                    if (!allCols.some(c => c.includes(colName))) {
                                        allCols.push(`    ${colName} ${type} UNIQUE NOT NULL`);
                                        const { cols: attrCols, pks: relPks, additionalSql } = this.getAttributeDefinitions(relation, root);
                                        allCols.push(...attrCols);
                                        allPKs.push(...relPks);
                                        extraSql += additionalSql;
                                        allFKs.push(`    FOREIGN KEY (${colName}) REFERENCES ${otherTableName}(${name}) ON DELETE CASCADE ON UPDATE CASCADE`);
                                    }
                                }
                            }
                        }
                    } else if (myEdge && this.getCardinality(myEdge).includes('1..1')) {
                        const connected = this.findConnectedEntities(relation, root);
                        let other = connected.find(e => e.id !== entity.id);
                        if (!other) {
                            const isReflexive = connected.length > 0 && connected.every(e => e.id === entity.id);
                            if (isReflexive) other = entity;
                        }
                        if (other) {
                            let otherEdge: GEdge | undefined;
                            if (entity.id === other.id) {
                                otherEdge = root.children.find(child => {
                                    const isEdge = child.type && child.type.includes('edge');
                                    if (!isEdge) return false;
                                    const e = child as GEdge;
                                    const connects = (e.sourceId === entity.id && e.targetId === relation.id) || (e.sourceId === relation.id && e.targetId === entity.id);
                                    return connects && e.id !== myEdge.id;
                                }) as GEdge | undefined;
                            } else otherEdge = this.findEdgeBetween(other, relation, root);

                            if (otherEdge && this.getCardinality(otherEdge).includes('1..1')) {
                                const isReflexive = entity.id === other.id;
                                if (isReflexive || entity.id > other.id) {
                                    const otherPK = this.findPrimaryKey(other, root);
                                    if (otherPK) {
                                        const { name, type } = this.splitLabelAttribute(this.getSafeName(otherPK));
                                        const relName = this.getSafeName(relation);
                                        const prefix = relName.substring(0, 3);
                                        const colName = isReflexive ? `${prefix}_${name}` : name;
                                        const otherTableName = this.getSafeName(other);
                                        if (!allCols.some(c => c.includes(colName))) {
                                            allCols.push(`    ${colName} ${type} UNIQUE NOT NULL`);
                                            const { cols: attrCols, pks: relPks, additionalSql } = this.getAttributeDefinitions(relation, root);
                                            allCols.push(...attrCols);
                                            allPKs.push(...relPks);
                                            extraSql += additionalSql;
                                            allFKs.push(`    FOREIGN KEY (${colName}) REFERENCES ${otherTableName}(${name}) ON DELETE CASCADE ON UPDATE CASCADE`);
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            }
        });*/